For 32 bit integer, positive value ranges from 0x00000000,.......,0x7fffffff(2147483647 in decimal)
and negative number ranges from 0x80000000(-2147483648 in decimal),.......,0xffffffff(-1 in decimal)

For 32 bit unsigned integer, value ranges from 0x00000000,......,0xffffffff(4294967295 in decimal)
-------------------------------------------------------------------------------------------------------------------------------------

1. Inject 0x7FFFFFFF for the “counter” value in the variable window, then step thru the program 
only once to increment “counter”.
a) What is the value of the “counter” from the “Locals” window?
	0x80000000 in Hexadecimal(in 2s complement format)
	-2147483648 in decimal
	
b) What is the value of the “counter” in the “Registers” window?
	0x80000000 in Hexadecimal(in 2s complement format)
	-2147483648 in decimal

c) Please note down which flags are set in the APSR register. And explain why
	Negative condition flag N is set to 1. Irrespective of whether signed or unsigned, it checks for MSB bit. If MSB is 1, then it sets flag N to 1.

	overflow condition flag V is set to 1. 
	Explaination - ALU doesn't care whether we are doing signed or unsigned mathematics. ALU just does the binary math and sets the flags appropriately. Internally, the overflow flag is usually generated by an exclusive-or of the internal carry into and out of the sign bit. 0x7fffffff + 0x1 =0x80000000. This changes MSB bit to 1. Thus turns on Overflow flag to 1.
	The sum of two numbers with the sign bit off yields a result number with the sign bit on, then the overflow flag is turned on.
	example : 0111 + 0001 = 1000 => overflow flag is turned on.

----------------------------------------------------------------------------------------------------------------------------------------

2. If your write all Fs (0xFFFFFFFF) in the Register value for “counter” then step thru the program 
once to increment “counter”
a) What happens to the value of “counter” in the “Locals” window?
	Value is 0. 
	0xFFFFFFFF(-1 in decimal) + 0x1 = 0x100000000(Here 1 being the carry)

b) Please note down which are set in the APSR register. And explain why.
	Zero flag(Z) is set to 1 Because the result becomes zero with the side effect of carry 1. 0xFFFFFFFF(-1 in decimal) + 0x1 = 0x100000000(Here 1 being the carry)

	Carry flag(C) is set to 1 Because it exceeds the 32 bit integer value range and the result becomes zero with the side effect of carry 1.  

-------------------------------------------------------------------------------------------------------------------------------------------

3. Change the “counter” variable type in your code to “unsigned int”. Inject the values 
“0x7FFFFFFF” then step thru the program to increment the “counter” once:
a) What is the value of “counter” in the “Locals” window after incrementing for each value?
	2147483648 in decimal. 
	0x80000000 in Hexadecimal
b) Please note down which flags are set in the APSR register. And explain why.
	Negative condition flag N is set to 1. Irrespective of whether signed or unsigned, it checks for MSB bit. If MSB is 1, then it sets flag N to 1.

	overflow condition flag V is set to 1.
	Explaination - ALU doesn't care whether we are doing signed or unsigned mathematics. ALU just does the binary math and sets the flags appropriately. Internally, the overflow flag is usually generated by an exclusive-or of the internal carry into and out of the sign bit. 0x7fffffff + 0x1 =0x80000000. This changes MSB bit to 1. Thus turns on Overflow flag to 1.
	The sum of two numbers with the sign bit off yields a result number with the sign bit on, then the overflow flag is turned on.
	example : 0111 + 0001 = 1000 => overflow flag is turned on. Usually we neglect overflow in unsigned integer arithmetic.

----------------------------------------------------------------------------------------------------------------------------

4. Change the “counter” variable type in your code to “unsigned”. Inject the values “0xFFFFFFFF” 
then step thru the program to increment the “counter” once:
a) What is the value of “counter” in the “Locals” window after incrementing for each value?
	Value is 0. 

b) Please note down which are set in the APSR register. And explain why.
	Zero flag(Z) is set to 1 Because the result becomes zero with the side effect of carry 1. 0xFFFFFFFF(4294967295 in decimal) + 0x1 = 0x100000000(Here 1 being the carry). This exceeds the 32 bit unsigned integer value range.

	Carry flag(C) is set to 1 Because it exceeds the 32 bit integer value range and the result becomes zero with the side effect of carry 1.  

-------------------------------------------------------------------------------------------------------------------------------

5. Move the “counter’ variable outside of main (at the top of the file):
a) What is the scope of the variable “counter”?
	Counter becomes global variable. It is now saved in SRAM and scope remains from the start till program ends

b) Is it still visible in the “Locals” view?
	Nope

c) In which window view can we track “counter” now?
	Watch window

d) What is the address of the “counter” variable in memory
	0x20000000

----------------------------------------------------------------------------------------------------------------------------

6. Change the source code to the following, then run the program in the simulator:
	int counter = 0x0;
	int main() {
	int *p_int = (int *)0x20000000;
	++(*p_int);
	++(*p_int);
	++(*p_int);
	counter ++;
	return 0;
	}

a) What is the value of “counter” at the end of the program (halting at the return 0 statement)
	4
	
b) Explain why the counter value has changed?
	Pointer is a variable which holds the address of another variable. Counter variable is stored in the SRAM address 0x20000000. Pointer variable is pointing to the address 0x20000000. Using dereffering operator, we are incrementing the address contents which in turn reflecting in counter variable.
----------------------------------------------------------------------------------------------------------------------------------------------

7. Change the setting of IAR to run the same program on the evaluation board:
int counter = 0x0;
int main() {
int *p_int = (int *)0x20000000;
++(*p_int);
++(*p_int);
++(*p_int);
counter ++;
return 0;
}
a) What is the address where “counter” is stored?

	0x20000000 

b) Is the “counter” variable stored in RAM or ROM?

	SRAM

c) What is the value of “counter” at the end of the program (halting at the return 0
statement).

	4
